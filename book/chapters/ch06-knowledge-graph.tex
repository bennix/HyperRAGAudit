\chapter{知识图谱构建}
\label{ch:knowledge-graph}

\section{为什么向量检索还不够}

向量检索擅长找到语义相关的文档片段，但有一个根本局限：\textbf{它不理解实体之间的关系}。

考虑以下审计场景：

\begin{quote}
"公司 A 的合同由张三签署，合同金额 500 万，但发票开给了公司 B，发票金额 520 万。"
\end{quote}

向量检索能找到包含"公司 A"或"500 万"的文档片段，但无法回答"张三签署的合同对应的发票是否金额一致"这类需要\textbf{关系推理}的问题。

知识图谱\index{知识图谱}（Knowledge Graph, KG）弥补了这一缺陷。它显式存储实体及其关系，支持路径查询和关系推理。

\section{实体与关系的定义}

\subsection{实体类型}

HyperRAG 定义了 7 种审计相关的实体类型：

\begin{table}[htbp]
\centering
\caption{实体类型定义}
\begin{tabular}{llp{6cm}}
\toprule
\textbf{类型} & \textbf{英文} & \textbf{示例} \\
\midrule
人物 & Person & 张三、李四、王总 \\
公司 & Company & 华为技术有限公司、腾讯 \\
金额 & Amount & 500万元、\$1,200,000 \\
日期 & Date & 2024年3月15日、Q2 2024 \\
法规 & Regulation & 《公司法》第42条、ISO 9001 \\
文档 & Document & 采购合同编号 HW-2024-001 \\
地点 & Location & 深圳市南山区、北京 \\
\bottomrule
\end{tabular}
\end{table}

\subsection{关系类型}

8 种关系类型覆盖了常见的审计关联：

\begin{table}[htbp]
\centering
\caption{关系类型定义}
\begin{tabular}{llp{5cm}}
\toprule
\textbf{关系} & \textbf{含义} & \textbf{示例} \\
\midrule
signed\_by & 签署 & 合同 $\rightarrow$ 张三 \\
issued\_by & 开具 & 发票 $\rightarrow$ 公司A \\
paid\_to & 付款 & 500万 $\rightarrow$ 公司B \\
dated & 日期关联 & 合同 $\rightarrow$ 2024-03-15 \\
regulated\_by & 受法规约束 & 采购流程 $\rightarrow$ 《采购法》 \\
located\_at & 位于 & 公司A $\rightarrow$ 深圳 \\
references & 引用 & 发票 $\rightarrow$ 合同编号 \\
amounts\_to & 金额对应 & 合同 $\rightarrow$ 500万 \\
\bottomrule
\end{tabular}
\end{table}

\subsection{数据模型}

\begin{lstlisting}[caption={Entity 和 Relation 模型}]
class Entity(BaseModel):
    name: str               # 实体名称（原文）
    entity_type: str        # 实体类型
    source_doc_id: str      # 来源文档 ID
    source_page: int        # 来源页码
    source_bbox: Optional[BBox] = None  # 来源坐标

class Relation(BaseModel):
    source_entity: str      # 源实体名称
    target_entity: str      # 目标实体名称
    relation_type: str      # 关系类型
    source_doc_id: str      # 来源文档 ID
    source_page: int        # 来源页码
\end{lstlisting}

\section{使用 LLM 提取实体与关系}

\subsection{提取提示词}

实体关系提取使用 Claude 模型，提示词位于 \texttt{prompts/entity\_extraction.txt}：

\begin{lstlisting}[language={},caption={实体提取提示词（节选）},basicstyle=\small\ttfamily]
You are an information extraction specialist.

ENTITY TYPES to extract:
- Person: names of individuals
- Company: company or organisation names
- Amount: monetary values with currency
- Date: dates, time periods, deadlines
...

RELATION TYPES to extract:
- signed_by: a document/contract signed by a person
- issued_by: a document issued by a company
...

RULES:
1. Only extract entities and relations that are
   explicitly stated in the text.
2. Each entity must include its exact name as it
   appears in the text.
...

OUTPUT JSON SCHEMA:
{
  "entities": [{"name": "...", "entity_type": "..."}],
  "relations": [{"source": "...", "target": "...",
                  "relation_type": "..."}]
}
\end{lstlisting}

\begin{warnbox}[提取准确性]
提示词中的第一条规则"Only extract entities and relations that are \textbf{explicitly stated}"至关重要。没有这条约束，LLM 可能会"推断"出文档中不存在的实体和关系，导致知识图谱中出现错误信息。
\end{warnbox}

\subsection{逐页提取}

为了控制 LLM 的输入长度和提高提取精度，采用逐页提取策略：

\begin{lstlisting}[caption={逐页实体提取}]
def extract(self, doc: ParsedDocument) -> tuple:
    all_entities, all_relations = [], []

    for page in doc.pages:
        page_text = "\n".join(
            b.text for b in page.content_blocks
        )
        if not page_text.strip():
            continue

        entities, relations = self._extract_from_page(
            doc_id=doc.doc_id,
            page_num=page.page_num,
            page_text=page_text,
            page=page,
        )
        all_entities.extend(entities)
        all_relations.extend(relations)

    # 实体去重
    all_entities = self._deduplicate_entities(all_entities)
    return all_entities, all_relations
\end{lstlisting}

\subsection{实体去重}

同一个实体可能在多个页面中出现。去重逻辑基于 (name.lower(), entity\_type.lower()) 的唯一组合：

\begin{lstlisting}[caption={实体去重}]
def _deduplicate_entities(self, entities):
    seen = {}
    for ent in entities:
        key = (ent.name.lower(), ent.entity_type.lower())
        if key not in seen:
            seen[key] = ent
    return list(seen.values())
\end{lstlisting}

\section{NetworkX 图存储}

HyperRAG 使用 NetworkX\index{NetworkX} 作为知识图谱的存储引擎。

\subsection{为什么选择 NetworkX}

\begin{table}[htbp]
\centering
\caption{图数据库选型对比}
\begin{tabular}{lp{4cm}p{4cm}}
\toprule
\textbf{方案} & \textbf{优势} & \textbf{劣势} \\
\midrule
Neo4j & 专业图数据库，Cypher 查询语言强大 & 需要单独部署，配置复杂 \\
NetworkX & 纯 Python，零部署，API 简洁 & 全在内存，不适合大规模 \\
Amazon Neptune & 托管服务，高可用 & 成本高，过重 \\
\bottomrule
\end{tabular}
\end{table}

对于 Streamlit 单用户场景，NetworkX 完全足够。

\subsection{图操作实现}

\begin{lstlisting}[caption={KnowledgeGraphStore 核心方法}]
import networkx as nx

class KnowledgeGraphStore:
    def __init__(self):
        self._graph = nx.DiGraph()  # 有向图

    def add_entities(self, entities: list[Entity]):
        for ent in entities:
            self._graph.add_node(
                ent.name,
                entity_type=ent.entity_type,
                source_doc_id=ent.source_doc_id,
                source_page=ent.source_page,
            )

    def add_relations(self, relations: list[Relation]):
        for rel in relations:
            self._graph.add_edge(
                rel.source_entity,
                rel.target_entity,
                relation_type=rel.relation_type,
                source_doc_id=rel.source_doc_id,
                source_page=rel.source_page,
            )
\end{lstlisting}

\subsection{邻居查询}

查询某个实体的 $n$ 跳邻居，用于 Agent 的关系探索：

\begin{lstlisting}[caption={邻居查询}]
def query_neighbors(self, entity: str, depth: int = 2):
    if entity not in self._graph:
        return {"nodes": [], "edges": []}

    # BFS 获取 n 跳子图
    nodes = set()
    frontier = {entity}
    for _ in range(depth):
        next_frontier = set()
        for n in frontier:
            for neighbor in (
                list(self._graph.successors(n))
                + list(self._graph.predecessors(n))
            ):
                if neighbor not in nodes:
                    next_frontier.add(neighbor)
        nodes |= frontier
        frontier = next_frontier
    nodes |= frontier

    # 构建子图
    subgraph = self._graph.subgraph(nodes)
    ...
\end{lstlisting}

\section{图谱的审计价值}

知识图谱在审计中的典型应用：

\begin{enumerate}
  \item \textbf{交叉验证}：同一笔交易在合同和发票中的金额是否一致？通过图路径连接合同实体和发票实体，比较 \texttt{amounts\_to} 关系的目标。
  \item \textbf{关系发现}：某个人同时签署了采购合同和验收报告——这是否构成利益冲突？
  \item \textbf{完整性检查}：每份合同是否都有对应的发票和验收单？检查 Document 类型节点的出边是否完整。
  \item \textbf{异常检测}：某个公司的所有合同都由同一人签署，且金额均略低于审批阈值——这是否为刻意规避审批？
\end{enumerate}

\begin{tipbox}[知识图谱 + 向量检索 = 混合搜索]
HyperRAG 的 Agent 同时拥有向量检索工具和知识图谱查询工具。这种\textbf{混合搜索}（Hybrid Search）策略让 Agent 既能找到语义相关的文本，又能追踪实体间的结构化关系，大幅提升审计推理的完整性。
\end{tipbox}
